//   NOTE: This -*- swift -*- source code is autogenerated from the AMQP
//         specification!
//
// TODO: license here
//

import Foundation

private typealias FieldValue = AMQP.FieldValue

extension AMQP.Basic.Qos: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(prefetchSize)
        try encoder.encode(prefetchCount)
        try encoder.encode(global)
    }

    init(from decoder: AMQPDecoder) throws {
        let prefetchSize = try decoder.decode(Int32.self)
        let prefetchCount = try decoder.decode(Int16.self)
        let global = try decoder.decode(Bool.self)
        self.init(
            prefetchSize: prefetchSize,
            prefetchCount: prefetchCount,
            global: global
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 + 4 }
}

extension AMQP.Basic.QosOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Basic.Consume: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(consumerTag, isLong: false)
        var bitPack: UInt8 = 0
        if noLocal { bitPack |= 1 << 0 }
        if noAck { bitPack |= 1 << 1 }
        if exclusive { bitPack |= 1 << 2 }
        if nowait { bitPack |= 1 << 3 }
        try encoder.encode(bitPack)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let consumerTag = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let noLocal: Bool = ((bitPack & (1 << 0)) != 0)
        let noAck: Bool = ((bitPack & (1 << 1)) != 0)
        let exclusive: Bool = ((bitPack & (1 << 2)) != 0)
        let nowait: Bool = ((bitPack & (1 << 3)) != 0)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            consumerTag: consumerTag,
            noLocal: noLocal,
            noAck: noAck,
            exclusive: exclusive,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 1 + 1 + 2 + 4 + UInt32(consumerTag.shortBytesCount) + UInt32(queue.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Basic.ConsumeOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(consumerTag, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        self.init(
            consumerTag: consumerTag
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(consumerTag.shortBytesCount) }
}

extension AMQP.Basic.Cancel: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(consumerTag, isLong: false)
        try encoder.encode(nowait)
    }

    init(from decoder: AMQPDecoder) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        self.init(
            consumerTag: consumerTag,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 4 + UInt32(consumerTag.shortBytesCount) }
}

extension AMQP.Basic.CancelOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(consumerTag, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        self.init(
            consumerTag: consumerTag
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(consumerTag.shortBytesCount) }
}

extension AMQP.Basic.Publish: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        var bitPack: UInt8 = 0
        if mandatory { bitPack |= 1 << 0 }
        if immediate { bitPack |= 1 << 1 }
        try encoder.encode(bitPack)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let mandatory: Bool = ((bitPack & (1 << 0)) != 0)
        let immediate: Bool = ((bitPack & (1 << 1)) != 0)
        self.init(
            ticket: ticket,
            exchange: exchange,
            routingKey: routingKey,
            mandatory: mandatory,
            immediate: immediate
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 2 + 4 + UInt32(exchange.shortBytesCount) + UInt32(routingKey.shortBytesCount) }
}

extension AMQP.Basic.Return: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(replyCode)
        try encoder.encode(replyText, isLong: false)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let replyCode = try decoder.decode(Int16.self)
        let replyText = try decoder.decode(String.self, isLong: false)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        self.init(
            replyCode: replyCode,
            replyText: replyText,
            exchange: exchange,
            routingKey: routingKey
        )
    }

    var bytesCount: UInt32 { 2 + 4 + UInt32(exchange.shortBytesCount) + UInt32(replyText.shortBytesCount) + UInt32(routingKey.shortBytesCount) }
}

extension AMQP.Basic.Deliver: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(consumerTag, isLong: false)
        try encoder.encode(deliveryTag)
        try encoder.encode(redelivered)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        let deliveryTag = try decoder.decode(Int64.self)
        let redelivered = try decoder.decode(Bool.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        self.init(
            consumerTag: consumerTag,
            deliveryTag: deliveryTag,
            redelivered: redelivered,
            exchange: exchange,
            routingKey: routingKey
        )
    }

    var bytesCount: UInt32 { 1 + 4 + 8 + UInt32(consumerTag.shortBytesCount) + UInt32(exchange.shortBytesCount) + UInt32(routingKey.shortBytesCount) }
}

extension AMQP.Basic.Get: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(noAck)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let noAck = try decoder.decode(Bool.self)
        self.init(
            ticket: ticket,
            queue: queue,
            noAck: noAck
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 + UInt32(queue.shortBytesCount) }
}

extension AMQP.Basic.GetOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(deliveryTag)
        try encoder.encode(redelivered)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(messageCount)
    }

    init(from decoder: AMQPDecoder) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let redelivered = try decoder.decode(Bool.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let messageCount = try decoder.decode(Int32.self)
        self.init(
            deliveryTag: deliveryTag,
            redelivered: redelivered,
            exchange: exchange,
            routingKey: routingKey,
            messageCount: messageCount
        )
    }

    var bytesCount: UInt32 { 1 + 4 + 4 + 8 + UInt32(exchange.shortBytesCount) + UInt32(routingKey.shortBytesCount) }
}

extension AMQP.Basic.GetEmpty: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(clusterId, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let clusterId = try decoder.decode(String.self, isLong: false)
        self.init(
            clusterId: clusterId
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(clusterId.shortBytesCount) }
}

extension AMQP.Basic.Ack: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(deliveryTag)
        try encoder.encode(multiple)
    }

    init(from decoder: AMQPDecoder) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let multiple = try decoder.decode(Bool.self)
        self.init(
            deliveryTag: deliveryTag,
            multiple: multiple
        )
    }

    var bytesCount: UInt32 { 1 + 4 + 8 }
}

extension AMQP.Basic.Reject: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(deliveryTag)
        try encoder.encode(requeue)
    }

    init(from decoder: AMQPDecoder) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let requeue = try decoder.decode(Bool.self)
        self.init(
            deliveryTag: deliveryTag,
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 + 4 + 8 }
}

extension AMQP.Basic.RecoverAsync: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(requeue)
    }

    init(from decoder: AMQPDecoder) throws {
        let requeue = try decoder.decode(Bool.self)
        self.init(
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 + 4 }
}

extension AMQP.Basic.Recover: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(requeue)
    }

    init(from decoder: AMQPDecoder) throws {
        let requeue = try decoder.decode(Bool.self)
        self.init(
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 + 4 }
}

extension AMQP.Basic.RecoverOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Basic.Nack: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(deliveryTag)
        var bitPack: UInt8 = 0
        if multiple { bitPack |= 1 << 0 }
        if requeue { bitPack |= 1 << 1 }
        try encoder.encode(bitPack)
    }

    init(from decoder: AMQPDecoder) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let multiple: Bool = ((bitPack & (1 << 0)) != 0)
        let requeue: Bool = ((bitPack & (1 << 1)) != 0)
        self.init(
            deliveryTag: deliveryTag,
            multiple: multiple,
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 4 + 8 }
}

extension AMQP.Connection.Start: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(versionMajor)
        try encoder.encode(versionMinor)
        try encoder.encode(serverProperties)
        try encoder.encode(mechanisms, isLong: true)
        try encoder.encode(locales, isLong: true)
    }

    init(from decoder: AMQPDecoder) throws {
        let versionMajor = try decoder.decode(Int8.self)
        let versionMinor = try decoder.decode(Int8.self)
        let serverProperties = try decoder.decode([String: FieldValue].self)
        let mechanisms = try decoder.decode(String.self, isLong: true)
        let locales = try decoder.decode(String.self, isLong: true)
        self.init(
            versionMajor: versionMajor,
            versionMinor: versionMinor,
            serverProperties: serverProperties,
            mechanisms: mechanisms,
            locales: locales
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 4 + locales.longBytesCount + mechanisms.longBytesCount + serverProperties.bytesCount }
}

extension AMQP.Connection.StartOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(clientProperties)
        try encoder.encode(mechanism, isLong: false)
        try encoder.encode(response, isLong: true)
        try encoder.encode(locale, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let clientProperties = try decoder.decode([String: FieldValue].self)
        let mechanism = try decoder.decode(String.self, isLong: false)
        let response = try decoder.decode(String.self, isLong: true)
        let locale = try decoder.decode(String.self, isLong: false)
        self.init(
            clientProperties: clientProperties,
            mechanism: mechanism,
            response: response,
            locale: locale
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(locale.shortBytesCount) + UInt32(mechanism.shortBytesCount) + clientProperties.bytesCount + response.longBytesCount }
}

extension AMQP.Connection.Secure: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(challenge, isLong: true)
    }

    init(from decoder: AMQPDecoder) throws {
        let challenge = try decoder.decode(String.self, isLong: true)
        self.init(
            challenge: challenge
        )
    }

    var bytesCount: UInt32 { 4 + challenge.longBytesCount }
}

extension AMQP.Connection.SecureOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(response, isLong: true)
    }

    init(from decoder: AMQPDecoder) throws {
        let response = try decoder.decode(String.self, isLong: true)
        self.init(
            response: response
        )
    }

    var bytesCount: UInt32 { 4 + response.longBytesCount }
}

extension AMQP.Connection.Tune: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(channelMax)
        try encoder.encode(frameMax)
        try encoder.encode(heartbeat)
    }

    init(from decoder: AMQPDecoder) throws {
        let channelMax = try decoder.decode(Int16.self)
        let frameMax = try decoder.decode(Int32.self)
        let heartbeat = try decoder.decode(Int16.self)
        self.init(
            channelMax: channelMax,
            frameMax: frameMax,
            heartbeat: heartbeat
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 4 + 4 }
}

extension AMQP.Connection.TuneOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(channelMax)
        try encoder.encode(frameMax)
        try encoder.encode(heartbeat)
    }

    init(from decoder: AMQPDecoder) throws {
        let channelMax = try decoder.decode(Int16.self)
        let frameMax = try decoder.decode(Int32.self)
        let heartbeat = try decoder.decode(Int16.self)
        self.init(
            channelMax: channelMax,
            frameMax: frameMax,
            heartbeat: heartbeat
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 4 + 4 }
}

extension AMQP.Connection.Open: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(virtualHost, isLong: false)
        try encoder.encode(capabilities, isLong: false)
        try encoder.encode(insist)
    }

    init(from decoder: AMQPDecoder) throws {
        let virtualHost = try decoder.decode(String.self, isLong: false)
        let capabilities = try decoder.decode(String.self, isLong: false)
        let insist = try decoder.decode(Bool.self)
        self.init(
            virtualHost: virtualHost,
            capabilities: capabilities,
            insist: insist
        )
    }

    var bytesCount: UInt32 { 1 + 4 + UInt32(capabilities.shortBytesCount) + UInt32(virtualHost.shortBytesCount) }
}

extension AMQP.Connection.OpenOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(knownHosts, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let knownHosts = try decoder.decode(String.self, isLong: false)
        self.init(
            knownHosts: knownHosts
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(knownHosts.shortBytesCount) }
}

extension AMQP.Connection.Close: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(replyCode)
        try encoder.encode(replyText, isLong: false)
        try encoder.encode(classId)
        try encoder.encode(methodId)
    }

    init(from decoder: AMQPDecoder) throws {
        let replyCode = try decoder.decode(Int16.self)
        let replyText = try decoder.decode(String.self, isLong: false)
        let classId = try decoder.decode(Int16.self)
        let methodId = try decoder.decode(Int16.self)
        self.init(
            replyCode: replyCode,
            replyText: replyText,
            classId: classId,
            methodId: methodId
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 2 + 4 + UInt32(replyText.shortBytesCount) }
}

extension AMQP.Connection.CloseOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Connection.Blocked: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(reason, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let reason = try decoder.decode(String.self, isLong: false)
        self.init(
            reason: reason
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(reason.shortBytesCount) }
}

extension AMQP.Connection.Unblocked: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Connection.UpdateSecret: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(newSecret, isLong: true)
        try encoder.encode(reason, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let newSecret = try decoder.decode(String.self, isLong: true)
        let reason = try decoder.decode(String.self, isLong: false)
        self.init(
            newSecret: newSecret,
            reason: reason
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(reason.shortBytesCount) + newSecret.longBytesCount }
}

extension AMQP.Connection.UpdateSecretOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Channel.Open: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(outOfBand, isLong: false)
    }

    init(from decoder: AMQPDecoder) throws {
        let outOfBand = try decoder.decode(String.self, isLong: false)
        self.init(
            outOfBand: outOfBand
        )
    }

    var bytesCount: UInt32 { 4 + UInt32(outOfBand.shortBytesCount) }
}

extension AMQP.Channel.OpenOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(channelId, isLong: true)
    }

    init(from decoder: AMQPDecoder) throws {
        let channelId = try decoder.decode(String.self, isLong: true)
        self.init(
            channelId: channelId
        )
    }

    var bytesCount: UInt32 { 4 + channelId.longBytesCount }
}

extension AMQP.Channel.Flow: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(active)
    }

    init(from decoder: AMQPDecoder) throws {
        let active = try decoder.decode(Bool.self)
        self.init(
            active: active
        )
    }

    var bytesCount: UInt32 { 1 + 4 }
}

extension AMQP.Channel.FlowOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(active)
    }

    init(from decoder: AMQPDecoder) throws {
        let active = try decoder.decode(Bool.self)
        self.init(
            active: active
        )
    }

    var bytesCount: UInt32 { 1 + 4 }
}

extension AMQP.Channel.Close: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(replyCode)
        try encoder.encode(replyText, isLong: false)
        try encoder.encode(classId)
        try encoder.encode(methodId)
    }

    init(from decoder: AMQPDecoder) throws {
        let replyCode = try decoder.decode(Int16.self)
        let replyText = try decoder.decode(String.self, isLong: false)
        let classId = try decoder.decode(Int16.self)
        let methodId = try decoder.decode(Int16.self)
        self.init(
            replyCode: replyCode,
            replyText: replyText,
            classId: classId,
            methodId: methodId
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 2 + 4 + UInt32(replyText.shortBytesCount) }
}

extension AMQP.Channel.CloseOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Access.Request: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(realm, isLong: false)
        var bitPack: UInt8 = 0
        if exclusive { bitPack |= 1 << 0 }
        if passive { bitPack |= 1 << 1 }
        if active { bitPack |= 1 << 2 }
        if write { bitPack |= 1 << 3 }
        if read { bitPack |= 1 << 4 }
        try encoder.encode(bitPack)
    }

    init(from decoder: AMQPDecoder) throws {
        let realm = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let exclusive: Bool = ((bitPack & (1 << 0)) != 0)
        let passive: Bool = ((bitPack & (1 << 1)) != 0)
        let active: Bool = ((bitPack & (1 << 2)) != 0)
        let write: Bool = ((bitPack & (1 << 3)) != 0)
        let read: Bool = ((bitPack & (1 << 4)) != 0)
        self.init(
            realm: realm,
            exclusive: exclusive,
            passive: passive,
            active: active,
            write: write,
            read: read
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 1 + 1 + 1 + 4 + UInt32(realm.shortBytesCount) }
}

extension AMQP.Access.RequestOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        self.init(
            ticket: ticket
        )
    }

    var bytesCount: UInt32 { 2 + 4 }
}

extension AMQP.Exchange.Declare: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(type, isLong: false)
        var bitPack: UInt8 = 0
        if passive { bitPack |= 1 << 0 }
        if durable { bitPack |= 1 << 1 }
        if autoDelete { bitPack |= 1 << 2 }
        if `internal` { bitPack |= 1 << 3 }
        if nowait { bitPack |= 1 << 4 }
        try encoder.encode(bitPack)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let type = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let passive: Bool = ((bitPack & (1 << 0)) != 0)
        let durable: Bool = ((bitPack & (1 << 1)) != 0)
        let autoDelete: Bool = ((bitPack & (1 << 2)) != 0)
        let `internal`: Bool = ((bitPack & (1 << 3)) != 0)
        let nowait: Bool = ((bitPack & (1 << 4)) != 0)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            exchange: exchange,
            type: type,
            passive: passive,
            durable: durable,
            autoDelete: autoDelete,
            internal: `internal`,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 1 + 1 + 1 + 2 + 4 + UInt32(exchange.shortBytesCount) + UInt32(type.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Exchange.DeclareOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Exchange.Delete: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(exchange, isLong: false)
        var bitPack: UInt8 = 0
        if ifUnused { bitPack |= 1 << 0 }
        if nowait { bitPack |= 1 << 1 }
        try encoder.encode(bitPack)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let ifUnused: Bool = ((bitPack & (1 << 0)) != 0)
        let nowait: Bool = ((bitPack & (1 << 1)) != 0)
        self.init(
            ticket: ticket,
            exchange: exchange,
            ifUnused: ifUnused,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 2 + 4 + UInt32(exchange.shortBytesCount) }
}

extension AMQP.Exchange.DeleteOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Exchange.Bind: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(destination, isLong: false)
        try encoder.encode(source, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(nowait)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let destination = try decoder.decode(String.self, isLong: false)
        let source = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            destination: destination,
            source: source,
            routingKey: routingKey,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 + UInt32(destination.shortBytesCount) + UInt32(routingKey.shortBytesCount) + UInt32(source.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Exchange.BindOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Exchange.Unbind: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(destination, isLong: false)
        try encoder.encode(source, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(nowait)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let destination = try decoder.decode(String.self, isLong: false)
        let source = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            destination: destination,
            source: source,
            routingKey: routingKey,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 + UInt32(destination.shortBytesCount) + UInt32(routingKey.shortBytesCount) + UInt32(source.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Exchange.UnbindOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Queue.Declare: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        var bitPack: UInt8 = 0
        if passive { bitPack |= 1 << 0 }
        if durable { bitPack |= 1 << 1 }
        if exclusive { bitPack |= 1 << 2 }
        if autoDelete { bitPack |= 1 << 3 }
        if nowait { bitPack |= 1 << 4 }
        try encoder.encode(bitPack)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let passive: Bool = ((bitPack & (1 << 0)) != 0)
        let durable: Bool = ((bitPack & (1 << 1)) != 0)
        let exclusive: Bool = ((bitPack & (1 << 2)) != 0)
        let autoDelete: Bool = ((bitPack & (1 << 3)) != 0)
        let nowait: Bool = ((bitPack & (1 << 4)) != 0)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            passive: passive,
            durable: durable,
            exclusive: exclusive,
            autoDelete: autoDelete,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 1 + 1 + 1 + 2 + 4 + UInt32(queue.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Queue.DeclareOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(queue, isLong: false)
        try encoder.encode(messageCount)
        try encoder.encode(consumerCount)
    }

    init(from decoder: AMQPDecoder) throws {
        let queue = try decoder.decode(String.self, isLong: false)
        let messageCount = try decoder.decode(Int32.self)
        let consumerCount = try decoder.decode(Int32.self)
        self.init(
            queue: queue,
            messageCount: messageCount,
            consumerCount: consumerCount
        )
    }

    var bytesCount: UInt32 { 4 + 4 + 4 + UInt32(queue.shortBytesCount) }
}

extension AMQP.Queue.Bind: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(nowait)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            exchange: exchange,
            routingKey: routingKey,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 + UInt32(exchange.shortBytesCount) + UInt32(queue.shortBytesCount) + UInt32(routingKey.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Queue.BindOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Queue.Purge: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(nowait)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        self.init(
            ticket: ticket,
            queue: queue,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 + UInt32(queue.shortBytesCount) }
}

extension AMQP.Queue.PurgeOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(messageCount)
    }

    init(from decoder: AMQPDecoder) throws {
        let messageCount = try decoder.decode(Int32.self)
        self.init(
            messageCount: messageCount
        )
    }

    var bytesCount: UInt32 { 4 + 4 }
}

extension AMQP.Queue.Delete: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        var bitPack: UInt8 = 0
        if ifUnused { bitPack |= 1 << 0 }
        if ifEmpty { bitPack |= 1 << 1 }
        if nowait { bitPack |= 1 << 2 }
        try encoder.encode(bitPack)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let ifUnused: Bool = ((bitPack & (1 << 0)) != 0)
        let ifEmpty: Bool = ((bitPack & (1 << 1)) != 0)
        let nowait: Bool = ((bitPack & (1 << 2)) != 0)
        self.init(
            ticket: ticket,
            queue: queue,
            ifUnused: ifUnused,
            ifEmpty: ifEmpty,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 1 + 1 + 2 + 4 + UInt32(queue.shortBytesCount) }
}

extension AMQP.Queue.DeleteOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(messageCount)
    }

    init(from decoder: AMQPDecoder) throws {
        let messageCount = try decoder.decode(Int32.self)
        self.init(
            messageCount: messageCount
        )
    }

    var bytesCount: UInt32 { 4 + 4 }
}

extension AMQP.Queue.Unbind: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(arguments)
    }

    init(from decoder: AMQPDecoder) throws {
        let ticket = try decoder.decode(Int16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            exchange: exchange,
            routingKey: routingKey,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 2 + 4 + UInt32(exchange.shortBytesCount) + UInt32(queue.shortBytesCount) + UInt32(routingKey.shortBytesCount) + arguments.bytesCount }
}

extension AMQP.Queue.UnbindOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Tx.Select: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Tx.SelectOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Tx.Commit: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Tx.CommitOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Tx.Rollback: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Tx.RollbackOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP.Confirm.Select: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
        try encoder.encode(nowait)
    }

    init(from decoder: AMQPDecoder) throws {
        let nowait = try decoder.decode(Bool.self)
        self.init(
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 4 }
}

extension AMQP.Confirm.SelectOk: AMQPCodable {
    func encode(to encoder: AMQPEncoder) throws {
    }

    init(from decoder: AMQPDecoder) throws {
        self.init()
    }

    var bytesCount: UInt32 { 4 }
}

extension AMQP {
    typealias Factory = @Sendable (any AMQPDecoder) throws -> any AMQPCodable
    static func makeFactory(with classId: UInt16, and methodId: UInt16) throws -> Factory {
        switch (classId, methodId) {
        case (60, 10): return AMQP.Basic.Qos.init
        case (60, 11): return AMQP.Basic.QosOk.init
        case (60, 20): return AMQP.Basic.Consume.init
        case (60, 21): return AMQP.Basic.ConsumeOk.init
        case (60, 30): return AMQP.Basic.Cancel.init
        case (60, 31): return AMQP.Basic.CancelOk.init
        case (60, 40): return AMQP.Basic.Publish.init
        case (60, 50): return AMQP.Basic.Return.init
        case (60, 60): return AMQP.Basic.Deliver.init
        case (60, 70): return AMQP.Basic.Get.init
        case (60, 71): return AMQP.Basic.GetOk.init
        case (60, 72): return AMQP.Basic.GetEmpty.init
        case (60, 80): return AMQP.Basic.Ack.init
        case (60, 90): return AMQP.Basic.Reject.init
        case (60, 100): return AMQP.Basic.RecoverAsync.init
        case (60, 110): return AMQP.Basic.Recover.init
        case (60, 111): return AMQP.Basic.RecoverOk.init
        case (60, 120): return AMQP.Basic.Nack.init
        case (10, 10): return AMQP.Connection.Start.init
        case (10, 11): return AMQP.Connection.StartOk.init
        case (10, 20): return AMQP.Connection.Secure.init
        case (10, 21): return AMQP.Connection.SecureOk.init
        case (10, 30): return AMQP.Connection.Tune.init
        case (10, 31): return AMQP.Connection.TuneOk.init
        case (10, 40): return AMQP.Connection.Open.init
        case (10, 41): return AMQP.Connection.OpenOk.init
        case (10, 50): return AMQP.Connection.Close.init
        case (10, 51): return AMQP.Connection.CloseOk.init
        case (10, 60): return AMQP.Connection.Blocked.init
        case (10, 61): return AMQP.Connection.Unblocked.init
        case (10, 70): return AMQP.Connection.UpdateSecret.init
        case (10, 71): return AMQP.Connection.UpdateSecretOk.init
        case (20, 10): return AMQP.Channel.Open.init
        case (20, 11): return AMQP.Channel.OpenOk.init
        case (20, 20): return AMQP.Channel.Flow.init
        case (20, 21): return AMQP.Channel.FlowOk.init
        case (20, 40): return AMQP.Channel.Close.init
        case (20, 41): return AMQP.Channel.CloseOk.init
        case (30, 10): return AMQP.Access.Request.init
        case (30, 11): return AMQP.Access.RequestOk.init
        case (40, 10): return AMQP.Exchange.Declare.init
        case (40, 11): return AMQP.Exchange.DeclareOk.init
        case (40, 20): return AMQP.Exchange.Delete.init
        case (40, 21): return AMQP.Exchange.DeleteOk.init
        case (40, 30): return AMQP.Exchange.Bind.init
        case (40, 31): return AMQP.Exchange.BindOk.init
        case (40, 40): return AMQP.Exchange.Unbind.init
        case (40, 51): return AMQP.Exchange.UnbindOk.init
        case (50, 10): return AMQP.Queue.Declare.init
        case (50, 11): return AMQP.Queue.DeclareOk.init
        case (50, 20): return AMQP.Queue.Bind.init
        case (50, 21): return AMQP.Queue.BindOk.init
        case (50, 30): return AMQP.Queue.Purge.init
        case (50, 31): return AMQP.Queue.PurgeOk.init
        case (50, 40): return AMQP.Queue.Delete.init
        case (50, 41): return AMQP.Queue.DeleteOk.init
        case (50, 50): return AMQP.Queue.Unbind.init
        case (50, 51): return AMQP.Queue.UnbindOk.init
        case (90, 10): return AMQP.Tx.Select.init
        case (90, 11): return AMQP.Tx.SelectOk.init
        case (90, 20): return AMQP.Tx.Commit.init
        case (90, 21): return AMQP.Tx.CommitOk.init
        case (90, 30): return AMQP.Tx.Rollback.init
        case (90, 31): return AMQP.Tx.RollbackOk.init
        case (85, 10): return AMQP.Confirm.Select.init
        case (85, 11): return AMQP.Confirm.SelectOk.init
        default: throw AMQPError.DecodingError.unknownClassAndMethod(class: classId, method: methodId)
        }
    }
}
