//   NOTE: This -*- swift -*- source code is autogenerated from the AMQP
//         specification!
//
// This source file is part of the swift-amqp open source project
//
// Copyright (c) 2024-2025 swift-amqp project authors
// Licensed under Apache License 2.0
//
// See LICENSE for license information
//
// SPDX-License-Identifier: Apache-2.0
//

private typealias FieldValue = Spec.FieldValue

extension Spec.Basic.Qos: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(prefetchSize)
        try encoder.encode(prefetchCount)
        try encoder.encode(global)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let prefetchSize = try decoder.decode(Int32.self)
        let prefetchCount = try decoder.decode(UInt16.self)
        let global = try decoder.decode(Bool.self)
        self.init(
            prefetchSize: prefetchSize,
            prefetchCount: prefetchCount,
            global: global
        )
    }

    var bytesCount: UInt32 { 1 + 2 + 4 }
}

extension Spec.Basic.QosOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Basic.Consume: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(consumerTag, isLong: false)
        var bitPack: UInt8 = 0
        if noLocal { bitPack |= 1 << 0 }
        if noAck { bitPack |= 1 << 1 }
        if exclusive { bitPack |= 1 << 2 }
        if nowait { bitPack |= 1 << 3 }
        try encoder.encode(bitPack)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let consumerTag = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let noLocal: Bool = ((bitPack & (1 << 0)) != 0)
        let noAck: Bool = ((bitPack & (1 << 1)) != 0)
        let exclusive: Bool = ((bitPack & (1 << 2)) != 0)
        let nowait: Bool = ((bitPack & (1 << 3)) != 0)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            consumerTag: consumerTag,
            noLocal: noLocal,
            noAck: noAck,
            exclusive: exclusive,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 {
        1 + 2 + UInt32(consumerTag.shortBytesCount) + UInt32(queue.shortBytesCount) + arguments.bytesCount
    }
}

extension Spec.Basic.ConsumeOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(consumerTag, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        self.init(
            consumerTag: consumerTag
        )
    }

    var bytesCount: UInt32 { UInt32(consumerTag.shortBytesCount) }
}

extension Spec.Basic.Cancel: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(consumerTag, isLong: false)
        try encoder.encode(nowait)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        self.init(
            consumerTag: consumerTag,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + UInt32(consumerTag.shortBytesCount) }
}

extension Spec.Basic.CancelOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(consumerTag, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        self.init(
            consumerTag: consumerTag
        )
    }

    var bytesCount: UInt32 { UInt32(consumerTag.shortBytesCount) }
}

extension Spec.Basic.Publish: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        var bitPack: UInt8 = 0
        if mandatory { bitPack |= 1 << 0 }
        if immediate { bitPack |= 1 << 1 }
        try encoder.encode(bitPack)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let mandatory: Bool = ((bitPack & (1 << 0)) != 0)
        let immediate: Bool = ((bitPack & (1 << 1)) != 0)
        self.init(
            ticket: ticket,
            exchange: exchange,
            routingKey: routingKey,
            mandatory: mandatory,
            immediate: immediate
        )
    }

    var bytesCount: UInt32 { 1 + 2 + UInt32(exchange.shortBytesCount) + UInt32(routingKey.shortBytesCount) }
}

extension Spec.Basic.Return: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(replyCode)
        try encoder.encode(replyText, isLong: false)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let replyCode = try decoder.decode(UInt16.self)
        let replyText = try decoder.decode(String.self, isLong: false)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        self.init(
            replyCode: replyCode,
            replyText: replyText,
            exchange: exchange,
            routingKey: routingKey
        )
    }

    var bytesCount: UInt32 {
        2 + UInt32(exchange.shortBytesCount) + UInt32(replyText.shortBytesCount) + UInt32(routingKey.shortBytesCount)
    }
}

extension Spec.Basic.Deliver: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(consumerTag, isLong: false)
        try encoder.encode(deliveryTag)
        try encoder.encode(redelivered)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let consumerTag = try decoder.decode(String.self, isLong: false)
        let deliveryTag = try decoder.decode(Int64.self)
        let redelivered = try decoder.decode(Bool.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        self.init(
            consumerTag: consumerTag,
            deliveryTag: deliveryTag,
            redelivered: redelivered,
            exchange: exchange,
            routingKey: routingKey
        )
    }

    var bytesCount: UInt32 {
        1 + 8 + UInt32(consumerTag.shortBytesCount) + UInt32(exchange.shortBytesCount)
            + UInt32(routingKey.shortBytesCount)
    }
}

extension Spec.Basic.Get: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(noAck)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let noAck = try decoder.decode(Bool.self)
        self.init(
            ticket: ticket,
            queue: queue,
            noAck: noAck
        )
    }

    var bytesCount: UInt32 { 1 + 2 + UInt32(queue.shortBytesCount) }
}

extension Spec.Basic.GetOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(deliveryTag)
        try encoder.encode(redelivered)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(messageCount)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let redelivered = try decoder.decode(Bool.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let messageCount = try decoder.decode(Int32.self)
        self.init(
            deliveryTag: deliveryTag,
            redelivered: redelivered,
            exchange: exchange,
            routingKey: routingKey,
            messageCount: messageCount
        )
    }

    var bytesCount: UInt32 { 1 + 4 + 8 + UInt32(exchange.shortBytesCount) + UInt32(routingKey.shortBytesCount) }
}

extension Spec.Basic.GetEmpty: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(clusterId, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let clusterId = try decoder.decode(String.self, isLong: false)
        self.init(
            clusterId: clusterId
        )
    }

    var bytesCount: UInt32 { UInt32(clusterId.shortBytesCount) }
}

extension Spec.Basic.Ack: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(deliveryTag)
        try encoder.encode(multiple)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let multiple = try decoder.decode(Bool.self)
        self.init(
            deliveryTag: deliveryTag,
            multiple: multiple
        )
    }

    var bytesCount: UInt32 { 1 + 8 }
}

extension Spec.Basic.Reject: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(deliveryTag)
        try encoder.encode(requeue)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let requeue = try decoder.decode(Bool.self)
        self.init(
            deliveryTag: deliveryTag,
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 + 8 }
}

extension Spec.Basic.RecoverAsync: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(requeue)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let requeue = try decoder.decode(Bool.self)
        self.init(
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 }
}

extension Spec.Basic.Recover: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(requeue)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let requeue = try decoder.decode(Bool.self)
        self.init(
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 }
}

extension Spec.Basic.RecoverOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Basic.Nack: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(deliveryTag)
        var bitPack: UInt8 = 0
        if multiple { bitPack |= 1 << 0 }
        if requeue { bitPack |= 1 << 1 }
        try encoder.encode(bitPack)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let deliveryTag = try decoder.decode(Int64.self)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let multiple: Bool = ((bitPack & (1 << 0)) != 0)
        let requeue: Bool = ((bitPack & (1 << 1)) != 0)
        self.init(
            deliveryTag: deliveryTag,
            multiple: multiple,
            requeue: requeue
        )
    }

    var bytesCount: UInt32 { 1 + 8 }
}

extension Spec.Connection.Start: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(versionMajor)
        try encoder.encode(versionMinor)
        try encoder.encode(serverProperties)
        try encoder.encode(mechanisms, isLong: true)
        try encoder.encode(locales, isLong: true)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let versionMajor = try decoder.decode(Int8.self)
        let versionMinor = try decoder.decode(Int8.self)
        let serverProperties = try decoder.decode([String: FieldValue].self)
        let mechanisms = try decoder.decode(String.self, isLong: true)
        let locales = try decoder.decode(String.self, isLong: true)
        self.init(
            versionMajor: versionMajor,
            versionMinor: versionMinor,
            serverProperties: serverProperties,
            mechanisms: mechanisms,
            locales: locales
        )
    }

    var bytesCount: UInt32 { 1 + 1 + locales.longBytesCount + mechanisms.longBytesCount + serverProperties.bytesCount }
}

extension Spec.Connection.StartOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(clientProperties)
        try encoder.encode(mechanism, isLong: false)
        try encoder.encode(response, isLong: true)
        try encoder.encode(locale, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let clientProperties = try decoder.decode([String: FieldValue].self)
        let mechanism = try decoder.decode(String.self, isLong: false)
        let response = try decoder.decode(String.self, isLong: true)
        let locale = try decoder.decode(String.self, isLong: false)
        self.init(
            clientProperties: clientProperties,
            mechanism: mechanism,
            response: response,
            locale: locale
        )
    }

    var bytesCount: UInt32 {
        UInt32(locale.shortBytesCount) + UInt32(mechanism.shortBytesCount) + clientProperties.bytesCount
            + response.longBytesCount
    }
}

extension Spec.Connection.Secure: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(challenge, isLong: true)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let challenge = try decoder.decode(String.self, isLong: true)
        self.init(
            challenge: challenge
        )
    }

    var bytesCount: UInt32 { challenge.longBytesCount }
}

extension Spec.Connection.SecureOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(response, isLong: true)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let response = try decoder.decode(String.self, isLong: true)
        self.init(
            response: response
        )
    }

    var bytesCount: UInt32 { response.longBytesCount }
}

extension Spec.Connection.Tune: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(channelMax)
        try encoder.encode(frameMax)
        try encoder.encode(heartbeat)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let channelMax = try decoder.decode(UInt16.self)
        let frameMax = try decoder.decode(Int32.self)
        let heartbeat = try decoder.decode(UInt16.self)
        self.init(
            channelMax: channelMax,
            frameMax: frameMax,
            heartbeat: heartbeat
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 4 }
}

extension Spec.Connection.TuneOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(channelMax)
        try encoder.encode(frameMax)
        try encoder.encode(heartbeat)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let channelMax = try decoder.decode(UInt16.self)
        let frameMax = try decoder.decode(Int32.self)
        let heartbeat = try decoder.decode(UInt16.self)
        self.init(
            channelMax: channelMax,
            frameMax: frameMax,
            heartbeat: heartbeat
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 4 }
}

extension Spec.Connection.Open: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(virtualHost, isLong: false)
        try encoder.encode(capabilities, isLong: false)
        try encoder.encode(insist)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let virtualHost = try decoder.decode(String.self, isLong: false)
        let capabilities = try decoder.decode(String.self, isLong: false)
        let insist = try decoder.decode(Bool.self)
        self.init(
            virtualHost: virtualHost,
            capabilities: capabilities,
            insist: insist
        )
    }

    var bytesCount: UInt32 { 1 + UInt32(capabilities.shortBytesCount) + UInt32(virtualHost.shortBytesCount) }
}

extension Spec.Connection.OpenOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(knownHosts, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let knownHosts = try decoder.decode(String.self, isLong: false)
        self.init(
            knownHosts: knownHosts
        )
    }

    var bytesCount: UInt32 { UInt32(knownHosts.shortBytesCount) }
}

extension Spec.Connection.Close: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(replyCode)
        try encoder.encode(replyText, isLong: false)
        try encoder.encode(classId)
        try encoder.encode(methodId)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let replyCode = try decoder.decode(UInt16.self)
        let replyText = try decoder.decode(String.self, isLong: false)
        let classId = try decoder.decode(UInt16.self)
        let methodId = try decoder.decode(UInt16.self)
        self.init(
            replyCode: replyCode,
            replyText: replyText,
            classId: classId,
            methodId: methodId
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 2 + UInt32(replyText.shortBytesCount) }
}

extension Spec.Connection.CloseOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Connection.Blocked: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(reason, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let reason = try decoder.decode(String.self, isLong: false)
        self.init(
            reason: reason
        )
    }

    var bytesCount: UInt32 { UInt32(reason.shortBytesCount) }
}

extension Spec.Connection.Unblocked: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Connection.UpdateSecret: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(newSecret, isLong: true)
        try encoder.encode(reason, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let newSecret = try decoder.decode(String.self, isLong: true)
        let reason = try decoder.decode(String.self, isLong: false)
        self.init(
            newSecret: newSecret,
            reason: reason
        )
    }

    var bytesCount: UInt32 { UInt32(reason.shortBytesCount) + newSecret.longBytesCount }
}

extension Spec.Connection.UpdateSecretOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Channel.Open: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(outOfBand, isLong: false)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let outOfBand = try decoder.decode(String.self, isLong: false)
        self.init(
            outOfBand: outOfBand
        )
    }

    var bytesCount: UInt32 { UInt32(outOfBand.shortBytesCount) }
}

extension Spec.Channel.OpenOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(channelId, isLong: true)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let channelId = try decoder.decode(String.self, isLong: true)
        self.init(
            channelId: channelId
        )
    }

    var bytesCount: UInt32 { channelId.longBytesCount }
}

extension Spec.Channel.Flow: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(active)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let active = try decoder.decode(Bool.self)
        self.init(
            active: active
        )
    }

    var bytesCount: UInt32 { 1 }
}

extension Spec.Channel.FlowOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(active)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let active = try decoder.decode(Bool.self)
        self.init(
            active: active
        )
    }

    var bytesCount: UInt32 { 1 }
}

extension Spec.Channel.Close: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(replyCode)
        try encoder.encode(replyText, isLong: false)
        try encoder.encode(classId)
        try encoder.encode(methodId)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let replyCode = try decoder.decode(UInt16.self)
        let replyText = try decoder.decode(String.self, isLong: false)
        let classId = try decoder.decode(UInt16.self)
        let methodId = try decoder.decode(UInt16.self)
        self.init(
            replyCode: replyCode,
            replyText: replyText,
            classId: classId,
            methodId: methodId
        )
    }

    var bytesCount: UInt32 { 2 + 2 + 2 + UInt32(replyText.shortBytesCount) }
}

extension Spec.Channel.CloseOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Access.Request: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(realm, isLong: false)
        var bitPack: UInt8 = 0
        if exclusive { bitPack |= 1 << 0 }
        if passive { bitPack |= 1 << 1 }
        if active { bitPack |= 1 << 2 }
        if write { bitPack |= 1 << 3 }
        if read { bitPack |= 1 << 4 }
        try encoder.encode(bitPack)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let realm = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let exclusive: Bool = ((bitPack & (1 << 0)) != 0)
        let passive: Bool = ((bitPack & (1 << 1)) != 0)
        let active: Bool = ((bitPack & (1 << 2)) != 0)
        let write: Bool = ((bitPack & (1 << 3)) != 0)
        let read: Bool = ((bitPack & (1 << 4)) != 0)
        self.init(
            realm: realm,
            exclusive: exclusive,
            passive: passive,
            active: active,
            write: write,
            read: read
        )
    }

    var bytesCount: UInt32 { 1 + UInt32(realm.shortBytesCount) }
}

extension Spec.Access.RequestOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        self.init(
            ticket: ticket
        )
    }

    var bytesCount: UInt32 { 2 }
}

extension Spec.Exchange.Declare: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(type, isLong: false)
        var bitPack: UInt8 = 0
        if passive { bitPack |= 1 << 0 }
        if durable { bitPack |= 1 << 1 }
        if autoDelete { bitPack |= 1 << 2 }
        if `internal` { bitPack |= 1 << 3 }
        if nowait { bitPack |= 1 << 4 }
        try encoder.encode(bitPack)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let type = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let passive: Bool = ((bitPack & (1 << 0)) != 0)
        let durable: Bool = ((bitPack & (1 << 1)) != 0)
        let autoDelete: Bool = ((bitPack & (1 << 2)) != 0)
        let `internal`: Bool = ((bitPack & (1 << 3)) != 0)
        let nowait: Bool = ((bitPack & (1 << 4)) != 0)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            exchange: exchange,
            type: type,
            passive: passive,
            durable: durable,
            autoDelete: autoDelete,
            internal: `internal`,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 {
        1 + 2 + UInt32(exchange.shortBytesCount) + UInt32(type.shortBytesCount) + arguments.bytesCount
    }
}

extension Spec.Exchange.DeclareOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Exchange.Delete: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(exchange, isLong: false)
        var bitPack: UInt8 = 0
        if ifUnused { bitPack |= 1 << 0 }
        if nowait { bitPack |= 1 << 1 }
        try encoder.encode(bitPack)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let exchange = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let ifUnused: Bool = ((bitPack & (1 << 0)) != 0)
        let nowait: Bool = ((bitPack & (1 << 1)) != 0)
        self.init(
            ticket: ticket,
            exchange: exchange,
            ifUnused: ifUnused,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 2 + UInt32(exchange.shortBytesCount) }
}

extension Spec.Exchange.DeleteOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Exchange.Bind: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(destination, isLong: false)
        try encoder.encode(source, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(nowait)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let destination = try decoder.decode(String.self, isLong: false)
        let source = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            destination: destination,
            source: source,
            routingKey: routingKey,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 {
        1 + 2 + UInt32(destination.shortBytesCount) + UInt32(routingKey.shortBytesCount)
            + UInt32(source.shortBytesCount) + arguments.bytesCount
    }
}

extension Spec.Exchange.BindOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Exchange.Unbind: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(destination, isLong: false)
        try encoder.encode(source, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(nowait)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let destination = try decoder.decode(String.self, isLong: false)
        let source = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            destination: destination,
            source: source,
            routingKey: routingKey,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 {
        1 + 2 + UInt32(destination.shortBytesCount) + UInt32(routingKey.shortBytesCount)
            + UInt32(source.shortBytesCount) + arguments.bytesCount
    }
}

extension Spec.Exchange.UnbindOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Queue.Declare: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        var bitPack: UInt8 = 0
        if passive { bitPack |= 1 << 0 }
        if durable { bitPack |= 1 << 1 }
        if exclusive { bitPack |= 1 << 2 }
        if autoDelete { bitPack |= 1 << 3 }
        if nowait { bitPack |= 1 << 4 }
        try encoder.encode(bitPack)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let passive: Bool = ((bitPack & (1 << 0)) != 0)
        let durable: Bool = ((bitPack & (1 << 1)) != 0)
        let exclusive: Bool = ((bitPack & (1 << 2)) != 0)
        let autoDelete: Bool = ((bitPack & (1 << 3)) != 0)
        let nowait: Bool = ((bitPack & (1 << 4)) != 0)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            passive: passive,
            durable: durable,
            exclusive: exclusive,
            autoDelete: autoDelete,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 { 1 + 2 + UInt32(queue.shortBytesCount) + arguments.bytesCount }
}

extension Spec.Queue.DeclareOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(queue, isLong: false)
        try encoder.encode(messageCount)
        try encoder.encode(consumerCount)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let queue = try decoder.decode(String.self, isLong: false)
        let messageCount = try decoder.decode(Int32.self)
        let consumerCount = try decoder.decode(Int32.self)
        self.init(
            queue: queue,
            messageCount: messageCount,
            consumerCount: consumerCount
        )
    }

    var bytesCount: UInt32 { 4 + 4 + UInt32(queue.shortBytesCount) }
}

extension Spec.Queue.Bind: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(nowait)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            exchange: exchange,
            routingKey: routingKey,
            nowait: nowait,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 {
        1 + 2 + UInt32(exchange.shortBytesCount) + UInt32(queue.shortBytesCount) + UInt32(routingKey.shortBytesCount)
            + arguments.bytesCount
    }
}

extension Spec.Queue.BindOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Queue.Purge: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(nowait)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let nowait = try decoder.decode(Bool.self)
        self.init(
            ticket: ticket,
            queue: queue,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 2 + UInt32(queue.shortBytesCount) }
}

extension Spec.Queue.PurgeOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(messageCount)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let messageCount = try decoder.decode(Int32.self)
        self.init(
            messageCount: messageCount
        )
    }

    var bytesCount: UInt32 { 4 }
}

extension Spec.Queue.Delete: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        var bitPack: UInt8 = 0
        if ifUnused { bitPack |= 1 << 0 }
        if ifEmpty { bitPack |= 1 << 1 }
        if nowait { bitPack |= 1 << 2 }
        try encoder.encode(bitPack)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let bitPack: UInt8 = try decoder.decode(UInt8.self)
        let ifUnused: Bool = ((bitPack & (1 << 0)) != 0)
        let ifEmpty: Bool = ((bitPack & (1 << 1)) != 0)
        let nowait: Bool = ((bitPack & (1 << 2)) != 0)
        self.init(
            ticket: ticket,
            queue: queue,
            ifUnused: ifUnused,
            ifEmpty: ifEmpty,
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 + 2 + UInt32(queue.shortBytesCount) }
}

extension Spec.Queue.DeleteOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(messageCount)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let messageCount = try decoder.decode(Int32.self)
        self.init(
            messageCount: messageCount
        )
    }

    var bytesCount: UInt32 { 4 }
}

extension Spec.Queue.Unbind: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(ticket)
        try encoder.encode(queue, isLong: false)
        try encoder.encode(exchange, isLong: false)
        try encoder.encode(routingKey, isLong: false)
        try encoder.encode(arguments)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let ticket = try decoder.decode(UInt16.self)
        let queue = try decoder.decode(String.self, isLong: false)
        let exchange = try decoder.decode(String.self, isLong: false)
        let routingKey = try decoder.decode(String.self, isLong: false)
        let arguments = try decoder.decode([String: FieldValue].self)
        self.init(
            ticket: ticket,
            queue: queue,
            exchange: exchange,
            routingKey: routingKey,
            arguments: arguments
        )
    }

    var bytesCount: UInt32 {
        2 + UInt32(exchange.shortBytesCount) + UInt32(queue.shortBytesCount) + UInt32(routingKey.shortBytesCount)
            + arguments.bytesCount
    }
}

extension Spec.Queue.UnbindOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Tx.Select: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Tx.SelectOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Tx.Commit: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Tx.CommitOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Tx.Rollback: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Tx.RollbackOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec.Confirm.Select: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
        try encoder.encode(nowait)
    }

    init(from decoder: FrameDecoderProtocol) throws {
        let nowait = try decoder.decode(Bool.self)
        self.init(
            nowait: nowait
        )
    }

    var bytesCount: UInt32 { 1 }
}

extension Spec.Confirm.SelectOk: FrameCodable {
    func encode(to encoder: FrameEncoderProtocol) throws {
    }

    init(from decoder: FrameDecoderProtocol) throws {
        self.init()
    }

    var bytesCount: UInt32 { 0 }
}

extension Spec {
    typealias Factory = @Sendable (any FrameDecoderProtocol) throws -> any FrameCodable

    // swiftlint:disable:next all
    static func makeFactory(with classId: UInt16, and methodId: UInt16) throws -> Factory {
        switch (classId, methodId) {
        case (60, 10): return Spec.Basic.Qos.init
        case (60, 11): return Spec.Basic.QosOk.init
        case (60, 20): return Spec.Basic.Consume.init
        case (60, 21): return Spec.Basic.ConsumeOk.init
        case (60, 30): return Spec.Basic.Cancel.init
        case (60, 31): return Spec.Basic.CancelOk.init
        case (60, 40): return Spec.Basic.Publish.init
        case (60, 50): return Spec.Basic.Return.init
        case (60, 60): return Spec.Basic.Deliver.init
        case (60, 70): return Spec.Basic.Get.init
        case (60, 71): return Spec.Basic.GetOk.init
        case (60, 72): return Spec.Basic.GetEmpty.init
        case (60, 80): return Spec.Basic.Ack.init
        case (60, 90): return Spec.Basic.Reject.init
        case (60, 100): return Spec.Basic.RecoverAsync.init
        case (60, 110): return Spec.Basic.Recover.init
        case (60, 111): return Spec.Basic.RecoverOk.init
        case (60, 120): return Spec.Basic.Nack.init
        case (10, 10): return Spec.Connection.Start.init
        case (10, 11): return Spec.Connection.StartOk.init
        case (10, 20): return Spec.Connection.Secure.init
        case (10, 21): return Spec.Connection.SecureOk.init
        case (10, 30): return Spec.Connection.Tune.init
        case (10, 31): return Spec.Connection.TuneOk.init
        case (10, 40): return Spec.Connection.Open.init
        case (10, 41): return Spec.Connection.OpenOk.init
        case (10, 50): return Spec.Connection.Close.init
        case (10, 51): return Spec.Connection.CloseOk.init
        case (10, 60): return Spec.Connection.Blocked.init
        case (10, 61): return Spec.Connection.Unblocked.init
        case (10, 70): return Spec.Connection.UpdateSecret.init
        case (10, 71): return Spec.Connection.UpdateSecretOk.init
        case (20, 10): return Spec.Channel.Open.init
        case (20, 11): return Spec.Channel.OpenOk.init
        case (20, 20): return Spec.Channel.Flow.init
        case (20, 21): return Spec.Channel.FlowOk.init
        case (20, 40): return Spec.Channel.Close.init
        case (20, 41): return Spec.Channel.CloseOk.init
        case (30, 10): return Spec.Access.Request.init
        case (30, 11): return Spec.Access.RequestOk.init
        case (40, 10): return Spec.Exchange.Declare.init
        case (40, 11): return Spec.Exchange.DeclareOk.init
        case (40, 20): return Spec.Exchange.Delete.init
        case (40, 21): return Spec.Exchange.DeleteOk.init
        case (40, 30): return Spec.Exchange.Bind.init
        case (40, 31): return Spec.Exchange.BindOk.init
        case (40, 40): return Spec.Exchange.Unbind.init
        case (40, 51): return Spec.Exchange.UnbindOk.init
        case (50, 10): return Spec.Queue.Declare.init
        case (50, 11): return Spec.Queue.DeclareOk.init
        case (50, 20): return Spec.Queue.Bind.init
        case (50, 21): return Spec.Queue.BindOk.init
        case (50, 30): return Spec.Queue.Purge.init
        case (50, 31): return Spec.Queue.PurgeOk.init
        case (50, 40): return Spec.Queue.Delete.init
        case (50, 41): return Spec.Queue.DeleteOk.init
        case (50, 50): return Spec.Queue.Unbind.init
        case (50, 51): return Spec.Queue.UnbindOk.init
        case (90, 10): return Spec.Tx.Select.init
        case (90, 11): return Spec.Tx.SelectOk.init
        case (90, 20): return Spec.Tx.Commit.init
        case (90, 21): return Spec.Tx.CommitOk.init
        case (90, 30): return Spec.Tx.Rollback.init
        case (90, 31): return Spec.Tx.RollbackOk.init
        case (85, 10): return Spec.Confirm.Select.init
        case (85, 11): return Spec.Confirm.SelectOk.init
        default: throw FramingError.unknownClassAndMethod(class: classId, method: methodId)
        }
    }
}
